## 临时抱佛脚
还有一个小时微视三面，把脑子的想的写一下，理一理

### HTTP
#### 三次握手

1. 客户端发出一个 SYN 包，等待服务器确认
2. 服务器收到 SYN 包，自己也发送一个 SYN，即 SYN + ACK（`此时服务器已经知道，客户端的发送功能是正常的`）
3. 客户端收到 SYN + ACK 包，像服务器发送 ACK（`此时服务器知道客户端的发送和接受功能是正常的，自己的发送和接受也是正常的`）

#### 四次挥手
1. 客户端发送 FIN，用来关闭自己的数据传输（`通知服务器自己要关闭了`）
2. 服务器收到 FIN 后，发送 ACK 给客户端（`此时服务器知道客户端要关闭输出通道了`）
3. 服务器发送一个 FIN，用来关闭服务器的数据传输（`通知客户端自己要关闭了`）
4. 客户端收到 FIN 后，客户端进入 TIME_WAIT 状态（2min），然后发送一个 ACK 给服务器（`此时双方都知道对方要关闭自己的输入了，也都知道对方接受到了自己要关闭的信息`）

HTTP 应用程序要做好正确处理非预期关闭的准备。
如果在客户端执行事务的过程中，传输连接关闭了，那么，除非事务处理会带来一些副作用（post之类的，不是幂等），否则客户端就应该重新打开连接，并重试一次


### HTTP2.0
#### 二进制流（1.1是文本类型）
1. 一条 tcp 连接同时可以有多条流，流可以交织，所以可以同时传送多个流
2. 帧的通信的基本单位，包括长度、类型和流标识符
3. 帧可以根据流标识符来知道自己属于哪一条流

帧交织有许多好处：
  + 所有请求和响应都在一个套接字上发生。
  + 所有响应或请求都无法相互阻塞。
  + 减少了延迟。
  + 提高了页面加载速度。
  + 消除了对 HTTP 1.1 工具的需求

#### 报头压缩
可以对 header 进行压缩，当有重复的 header 时，只需要发送不同的地方

#### 流优先化
+ 可以分配流的优先级
+ 可以指定流的依赖关系（比如上一条流加载完成后再加载下一条）

#### 服务器推送
服务器能够预测客户端请求的资源，然后再完成请求前将资源发送到客户端。
比如请求一个 html 可以将其余的 js，图片等推送到客户端缓存中，在执行这些操作时，服务器仍在处理原始网页请求。等需要其他资源时，这些资源已经在缓存中了

+ 那么 HTTP/2 如何管理服务器推送而不会让客户端过载？
针对希望发送的每个资源，服务器会发送一个 `PUSH_PROMISE` 帧，但客户端可通过发送 `RST_STREAM` 帧作为响应来拒绝推送（例如，如果浏览器的缓存中已包含该资源）。重要的是所有 PUSH_PROMISE 都在响应数据之前发送，所以客户端知道它需要请求哪些资源。


#### HTTPS
为啥需要 https，比如 http 劫持，由于 http 是明文的，所以会泄漏用户信息

+ 什么是对称加密？
双方共用一把密钥，用这把密钥加密解密

+ 什么是非对称加密？
有一把公钥，一把私钥。公钥加密的私钥可以解开，或者私钥加密的公钥可以解开。服务器直接把公钥给客户端，客户端用公钥加密，这样只有服务器可以解开

+ https 加密方式
用非对称加密来加密对称加密的密钥，非对称加密的密钥有双方商定一些随机数共同生成。用证书来确保服务器发送的随机数是安全的，就是客户端用 ca 机构下发的证书公钥来检查服务器端证书的数字签名是否正常

SSL/TLS协议的基本过程是这样的：
  > + 客户端向服务器端索要并验证公钥
  > + 双方协商生成"对话密钥"
  > + 双方采用"对话密钥"进行加密通信